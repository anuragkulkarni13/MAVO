package vulnerability;

import java.nio.file.Files;
import java.nio.file.Paths;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.json.JSONArray;
import org.json.JSONObject;

import common.Constants;
import common.dto.DependencyDTO;
import common.dto.VersionDTO;
import common.dto.VulnerabilityDTO;
import db.DependencyCache;
import db.DependencyDB;
import pom.DependencyOperations;
import versionmanagement.VersionFetcher;

public class VulnerabilityAnalyzer {

	// scans the vulnerability report, updates the node and generates the analysis
	
	public static String getLeastVulnerableVersion(Connection connection, String originalPomPath, String groupId, String artifactId, String oldRecommendedVersion, 
			String tempPomFileLocation, String temppomDirectory, String tempPomDependencyTreePath, String dependencyCheckReportLocation, String moduleName)
	{
		
		int leastVulCount = 0;
		String leastVulCountVersion = "";
		
		VersionFetcher.fetchAllVersions(groupId, artifactId, oldRecommendedVersion, "");
		
		long fromTime = VersionFetcher.getTimeStampforDependency(groupId, artifactId, oldRecommendedVersion);
		
		List<VersionDTO> versions = VersionFetcher.fetchAllVersions(groupId, artifactId, oldRecommendedVersion, "");

		List<String> versionList = new ArrayList<>();

		if(!versions.isEmpty())
		{
			for(int i=versions.size()-1;i>=0;i--)
			{
				if(versions.get(i).getTimestamp()>=fromTime)
				{
					versionList.add(versions.get(i).getVersion());
				}
			}
		}
		
		if(versionList.size()>1)
		{
			for(String version : versionList)
			{
				DependencyOperations.updateDependencyVersion(tempPomFileLocation, groupId, artifactId, version);

				int vulCount = 0;
				String vulString = "";

				try {
					String key = groupId +"/"+ artifactId +"/"+ version;
					if(DependencyCache.isVulnerabilityKeyPresent(connection, key))
					{
						System.out.println("inside cache");
//						vulCount = Integer.parseInt(DependencyCache.getVulnerabilityCache(connection, key));
						
						vulString = DependencyCache.getVulnerabilityCache(connection, key);
						if(!vulString.equalsIgnoreCase("")) {
							String[] vulStringArr = vulString.split(",");
							vulCount = vulStringArr.length;							
						} else {
							vulCount = 0;
						}
					}
					else
					{
						System.out.println("outside cache");
						DependencyOperations.generateDependencyCheckReportWithPath(tempPomFileLocation, temppomDirectory, dependencyCheckReportLocation);
						Map<String, List<VulnerabilityDTO>> vulnerabilityMap = getVulnerabilityList(dependencyCheckReportLocation);
						
						for (Map.Entry<String, List<VulnerabilityDTO>> entry : vulnerabilityMap.entrySet()) {
						    System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue().size());
						    vulCount += entry.getValue().size();
						}
//						DependencyCache.putVulnerabilityCache(connection, key, String.valueOf(vulCount));
						
//						System.out.println("vulnerabilityMap - "+vulnerabilityMap);
						List<VulnerabilityDTO> vulnerabilities = vulnerabilityMap.get(artifactId);
						
						if(vulnerabilities!=null && vulnerabilities.size()>0)
						{
							int first = 0;
							for(VulnerabilityDTO vul : vulnerabilities)
							{
								if(first == 0)
								{
									vulString += vul.getVulnerabilityName();
									first = 1;
								}
								else
								{
									vulString += ","+vul.getVulnerabilityName();
								}
							}							
						}
						System.out.println("vulString - "+vulString);
						DependencyCache.putVulnerabilityCache(connection, key, vulString);
						
						DependencyDB.updateVulnerabilityInDependencyTable(connection, groupId, artifactId, version, vulString);
						
						if(!DependencyDB.isDependencyPresent(connection, groupId, artifactId) && !version.equalsIgnoreCase(oldRecommendedVersion)) {
							DependencyDB.putDependencyTableEntry(connection, groupId, artifactId, version, version, version, moduleName, Constants.normalDependencyType, "", Constants.temporaryDependencyNature, false, vulString, "");
						}
					}
					
					System.out.println(key+" - "+vulCount);
				} catch (SQLException e) {
					e.printStackTrace();
				}
				
				if(version.equalsIgnoreCase(oldRecommendedVersion))
				{
					leastVulCount = vulCount;
					if(vulCount == 0)
					{
						return oldRecommendedVersion;
					}
				}
				else
				{
					if(vulCount == 0)
					{
						return version;
					}
					else if(vulCount<leastVulCount)
					{
						leastVulCount = vulCount;
						leastVulCountVersion = version;
					}
					
				}
			}
			if(leastVulCountVersion.equalsIgnoreCase(""))
			{
				return oldRecommendedVersion;
			}
		}
		else
		{
			return oldRecommendedVersion;
		}
		return leastVulCountVersion;
	}
	
	public static Map<String, List<VulnerabilityDTO>> getVulnerabilityList(String dependencyCheckReportLocation)
	{
		Map<String, List<VulnerabilityDTO>> vulnerabilitiesMap = new HashMap<>();

		try {
			String content = new String(Files.readAllBytes(Paths.get(dependencyCheckReportLocation)));
			JSONObject jsonObject = new JSONObject(content);
			// Check if the "dependencies" array exists and is not null
			if (jsonObject.has("dependencies") && !jsonObject.isNull("dependencies")) {
				// Ensure that "dependencies" is actually a JSONArray
				if (jsonObject.get("dependencies") instanceof JSONArray) {
					JSONArray dependencyArray = jsonObject.getJSONArray("dependencies");
					for (int i = 0; i < dependencyArray.length(); i++) {

						List<VulnerabilityDTO> vulnerabilityList = new ArrayList<>();

						JSONObject dependencyObject = dependencyArray.getJSONObject(i);
						String fileName = dependencyObject.getString("fileName");
						String filePath = dependencyObject.getString("filePath");
						String[] filePathArr = filePath.split("\\\\");
						String artifactId = filePathArr[filePathArr.length - 3];
						String dependencyVersion = filePathArr[filePathArr.length - 2];
//                      System.out.println("filename : "+fileName);
						if (dependencyObject.has("vulnerabilities") && !dependencyObject.isNull("vulnerabilities")) {
							// Ensure that "dependencies" is actually a JSONArray
							if (dependencyObject.get("vulnerabilities") instanceof JSONArray) {
								JSONArray vulnerabilityArray = dependencyObject.getJSONArray("vulnerabilities");
								for (int j = 0; j < vulnerabilityArray.length(); j++) {

									JSONObject vulnerabilityObject = vulnerabilityArray.getJSONObject(j);
									String source = "";
									String vulnerabilityName = "";
									String severity = "";
									float baseScore = 0;
									String attackVector = "";
									String attackComplexity = "";
									String privilegesRequired = "";
									String userInteraction = "";
									String scope = "";
									String confidentialityImpact = "";
									String integrityImpact = "";
									String availabilityImpact = "";
									String baseSeverity = "";
									String exploitabilityScore = "";
									String impactScore = "";
									String version = "";

									source = vulnerabilityObject.getString("source");
									vulnerabilityName = vulnerabilityObject.getString("name");
									severity = vulnerabilityObject.getString("severity");
									if(vulnerabilityObject.has("cvssv3"))
									{
										JSONObject cvssv3Object = vulnerabilityObject.getJSONObject("cvssv3");
										baseScore = cvssv3Object.has("score")?cvssv3Object.getFloat("baseScore"):0;
										attackVector = cvssv3Object.has("score")?cvssv3Object.getString("attackVector"):"";
										attackComplexity = cvssv3Object.has("score")?cvssv3Object.getString("attackComplexity"):"";
										privilegesRequired = cvssv3Object.has("score")?cvssv3Object.getString("privilegesRequired"):"";
										userInteraction = cvssv3Object.has("score")?cvssv3Object.getString("userInteraction"):"";
										scope = cvssv3Object.has("score")?cvssv3Object.getString("scope"):"";
										confidentialityImpact = cvssv3Object.has("score")?cvssv3Object.getString("confidentialityImpact"):"";
										integrityImpact = cvssv3Object.has("score")?cvssv3Object.getString("integrityImpact"):"";
										availabilityImpact = cvssv3Object.has("score")?cvssv3Object.getString("availabilityImpact"):"";
										baseSeverity = cvssv3Object.has("score")?cvssv3Object.getString("baseSeverity"):"";
										exploitabilityScore = cvssv3Object.has("score")?cvssv3Object.getString("exploitabilityScore"):"";
										impactScore = cvssv3Object.has("score")?cvssv3Object.getString("impactScore"):"";
										version = cvssv3Object.has("score")?cvssv3Object.getString("version"):"";
									}
									else if(vulnerabilityObject.has("cvssv2"))
									{
										JSONObject cvssv2Object = vulnerabilityObject.getJSONObject("cvssv2");
										baseScore = cvssv2Object.has("score")?cvssv2Object.getFloat("score"):0;
										attackVector = cvssv2Object.has("accessVector")?cvssv2Object.getString("accessVector"):"";
										attackComplexity = cvssv2Object.has("accessComplexity")?cvssv2Object.getString("accessComplexity"):"";
										privilegesRequired = cvssv2Object.has("authenticationr")?cvssv2Object.getString("authenticationr"):"";
										confidentialityImpact = cvssv2Object.has("confidentialImpact")?cvssv2Object.getString("confidentialImpact"):"";
										integrityImpact = cvssv2Object.has("integrityImpact")?cvssv2Object.getString("integrityImpact"):"";
										availabilityImpact = cvssv2Object.has("availabilityImpact")?cvssv2Object.getString("availabilityImpact"):"";
										baseSeverity = cvssv2Object.has("severity")?cvssv2Object.getString("severity"):"";
										exploitabilityScore = cvssv2Object.has("exploitabilityScore")?cvssv2Object.getString("exploitabilityScore"):"";
										impactScore = cvssv2Object.has("impactScore")?cvssv2Object.getString("impactScore"):"";
										version = cvssv2Object.has("version")?cvssv2Object.getString("version"):"";
									}

									VulnerabilityDTO vulnerabilityDTO = new VulnerabilityDTO();
//									vulnerabilityDTO.setJarName(fileName);
									vulnerabilityDTO.setArtifactId(artifactId);
									vulnerabilityDTO.setDependencyVersion(dependencyVersion);
									vulnerabilityDTO.setSource(source);
									vulnerabilityDTO.setVulnerabilityName(vulnerabilityName);
									vulnerabilityDTO.setSeverity(severity);
									vulnerabilityDTO.setBaseScore(baseScore);
									vulnerabilityDTO.setAttackVector(attackVector);
									vulnerabilityDTO.setAttackComplexity(attackComplexity);
									vulnerabilityDTO.setPrivilegesRequired(privilegesRequired);
									vulnerabilityDTO.setUserInteraction(userInteraction);
									vulnerabilityDTO.setScope(scope);
									vulnerabilityDTO.setConfidentialityImpact(confidentialityImpact);
									vulnerabilityDTO.setIntegrityImpact(integrityImpact);
									vulnerabilityDTO.setAvailabilityImpact(availabilityImpact);
									vulnerabilityDTO.setBaseSeverity(baseSeverity);
									vulnerabilityDTO.setExploitabilityScore(exploitabilityScore);
									vulnerabilityDTO.setImpactScore(impactScore);
									vulnerabilityDTO.setVersion(version);

//                            		System.out.println(vulnerabilityDTO.getJarName());
									vulnerabilityList.add(vulnerabilityDTO);
								}
							}
						}
						if(vulnerabilityList.size()>0)
						{
							vulnerabilitiesMap.put(artifactId, vulnerabilityList);
						}
					}
				}
			}	        
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}

		return vulnerabilitiesMap;

	}

	public static void getVulCount(DependencyDTO root, Map<String,Integer> vulCount)
	{
		if(root.getVulnerabilities().size()>0)
		{
			vulCount.put(root.getGroupId()+"/"+root.getArtifactId()+"/"+root.getVersion(), root.getVulnerabilities().size());
		}
		List<DependencyDTO> children = root.getChildren();
		for(DependencyDTO child : children)
		{
			getVulCount(child, vulCount);
		}
	}

	public static int getTotalVulCount(Map<String,Integer> vulCount)
	{
		int totalVulCount = 0;
		for (Integer value : vulCount.values()) {
			totalVulCount += value;
		}
		return totalVulCount;
	}

	public static String getVulStringOfPom(String tempPomFileLocation, String temppomDirectory, String tempPomDependencyTreePath, String dependencyCheckReportLocation, Map<String, List<VulnerabilityDTO>> vulnerabilityMap)
	{
		String vulString = "";
		try {
			List<VulnerabilityDTO> vulnerabilities = new ArrayList<>();

			for (Map.Entry<String, List<VulnerabilityDTO>> entry : vulnerabilityMap.entrySet()) {
//			    System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue().size());
			    vulnerabilities.addAll(entry.getValue());
			}
			
			if(vulnerabilities!=null && vulnerabilities.size()>0)
			{
				int first = 0;
				for(VulnerabilityDTO vul : vulnerabilities)
				{
					if(first == 0)
					{
						vulString += vul.getVulnerabilityName();
						first = 1;
					}
					else
					{
						vulString += ","+vul.getVulnerabilityName();
					}
				}							
			}
//			System.out.println("vulString - "+vulString);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return vulString;
	}
	
	public static Map<String, List<VulnerabilityDTO>> getVulnerabilityMapOfPom(String tempPomFileLocation, String temppomDirectory, String tempPomDependencyTreePath, String dependencyCheckReportLocation) {
		
		Map<String, List<VulnerabilityDTO>> vulnerabilityMap = new HashMap<>();
		try {
			DependencyOperations.generateDependencyCheckReportWithPath(tempPomFileLocation, temppomDirectory, dependencyCheckReportLocation);
			vulnerabilityMap = getVulnerabilityList(dependencyCheckReportLocation);
			
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		return vulnerabilityMap;
	}
	
}
